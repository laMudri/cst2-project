Formal verification is becoming an increasingly important part of maintaining large software systems.
It has long been commonplace for compilers to verify some level of correctness of programs -- specifically, a compiler for a statically typed language will check the types of the program it is given.
If the type checker successfully checks an expression $e$ against a type $A$, we have a guarantee that when we evaluate $e$, any resulting value we get will be in a form specified by the definition of $A$.

With finer-grained types, we can have more thorough guarantees of correctness.
A type we can express in nearly all modern programming languages is the type of lists with at least one element.
We can encode this as a structure containing a value of element type and a (possibly empty) list of the remaining elements.
Using this non-empty list type justifies the use of functions which pick an element from a list, such as \texttt{head}, which picks the first element of a list.
\texttt{head} cannot be well behaved on an empty list because it has no first element to pick.
It must thus either return a \texttt{null} reference, throw an error, or explicitly state that it might not produce a value.

Dependent types are a relatively new feature to appear in programming languages, though they have a history stretching back to at least the 1970s\cite{martin-lof:aitot} and practical use in proof assistants since Coq\cite{CoqProofAssistant}, first released in 1989.
In a dependent type system, arbitrary expressions may appear in types, and thus we can make guarantees about those expressions which are checked by the type checker.
In theory, this makes programming languages with dependent types suitable for both writing programs and proving them correct.
One language aiming to do this is Agda\cite{Norell07}, which I use for the bulk of this project.

The other main component of the project is shortest distance problems.
In a shortest distance problem, we are given a weighted graph and a source vertex, and required to give, for each vertex, the shortest distance from the source to that vertex.
